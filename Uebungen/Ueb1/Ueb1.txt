Aufg1)
 a) Da versucht wird einen größeren DatenTyp(long) in einen kleineren(int) zu speichern
 b) entweder i = int(l) oder int i=c zu long i=c ändern
Aufg2)
 z.B. wenn 2. Argument eine Funktion/Methode ist und das erste Argument True ist:
	-> if(True & someFunk()) -> ruft someFunk auf - vs if(True && someFunk()) -> ruft someFunk nicht auf
Aufg4)
 b) -70609262346240000
 c) Overflow von Long -> Overflow flippt alle bits, so dass sie als -(Max_Wert(long)) interpretiert wird
Aufg5)
 a) Speicheraufwand: 8*n Byte, Zeitaufwand für Ausgabe der n Fib_Zahlen: n Takte
Aufg6)
 -Hat 2 Attribute (x, y) vom Typ int
 -3 Konstruktoren mitunter, einen Default Konstruktor
 -getLocation-Methode, die die aktuelle Location(x-, y-Koordinate zurückgibt in Form eines Point-Objekts)
 -Überladene set-Methode(setLocation), die entweder einen Point oder zwei Int-Werte als Argumente entgegen nimmt
 -Move-Methode, um von der Aktuellen Position(x, y) sich um dx bzw. dy zu bewegen
 -eine Equals-Methode, um Vergleiche zwischen zwei Objekten einer Klasse darzustellen
 -eine toString-Methode, um ein Point-Objekt als String zu returnen

